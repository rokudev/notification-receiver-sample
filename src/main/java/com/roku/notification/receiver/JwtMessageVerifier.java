package com.roku.notification.receiver;

import com.auth0.jwk.InvalidPublicKeyException;
import com.auth0.jwk.Jwk;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.interfaces.JWTVerifier;

import java.security.PublicKey;
import java.security.interfaces.RSAPublicKey;

/**
 * This class verifies the signature of a JWT message. The signature is generated by a private key.
 * This class makes sure to use the corresponding public key when verifying the signature.
 * A private/public key pair is associated with a key ID (kid) that uniquely identifies the key pair.
 *
 * This class caches the current active kid and its corresponding JWTVerifier. When encountering a
 * new kid in the header of a JWT message, this class will use JwkProvider to fetch
 * the needed public key and use that to create a new JWTVerifier. The class will also update the
 * cached active kid and JWTVerifier.
 */
public class JwtMessageVerifier {
    private JwkProvider jwkProvider;

    // The cached JWT verifier
    private JWTVerifier verifier;

    // The cached kid
    private String activeKid = "";

    public JwtMessageVerifier(JwkProvider jwkProvider) {
        this.jwkProvider = jwkProvider;
    }

    /**
     * Verify the signature of a JWT message.
     *
     * @param jwtMessage the JWT message to verify
     * @return the decoded JWT message
     */
    public DecodedJWT verifyJwt(String jwtMessage) {
        ensureVerifierUpdated(jwtMessage);
        try {
            DecodedJWT jwt = verifier.verify(jwtMessage);
            return jwt;
        } catch (JWTVerificationException e){
            throw new RuntimeException(e);
        }
    }

    // If the kid field in the decoded jwtMessage is not the same as the activeKid,
    // this method will download the public key that corresponds to the kid and use
    // the public key to create a new JWTVerifier.
    private void ensureVerifierUpdated(String jwtMessage) {
        DecodedJWT decodedJWT = decodedJWT(jwtMessage);
        String kid = getKid(decodedJWT);
        if (!activeKid.equals(kid)) {
            updateVerifier(kid);
        }
    }

    // Use JwkProvider to download the public key that corresponds to the kid and use
    // the public key to create a new JWTVerifier.
    private void updateVerifier(String kid) {
        Jwk jwk = jwkProvider.get(kid);
        RSAPublicKey publicKey = (RSAPublicKey) getPublicKey(jwk);
        Algorithm algorithm = Algorithm.RSA256(publicKey, null);
        verifier = JWT.require(algorithm)
                .withIssuer("Roku, Inc. urn:roku:apps:partner-service.roku.com")
                .build();
        activeKid = kid;
    }

    private PublicKey getPublicKey(Jwk jwk) {
        try {
            return jwk.getPublicKey();
        } catch (InvalidPublicKeyException e) {
            throw new RuntimeException("Failed to get valid public key", e);
        }
    }

    private String getKid(DecodedJWT decodedJWT) {
        Claim kidClaim = decodedJWT.getHeaderClaim("kid");
        if (kidClaim.isNull()) {
            throw new RuntimeException("Missing kid claim in JWT header");
        }
        return kidClaim.asString();
    }

    private DecodedJWT decodedJWT(String jwtMessage) {
        try {
            return JWT.decode(jwtMessage);
        } catch (JWTDecodeException e){
            throw new RuntimeException("Invalid jwt token", e);
        }
    }
}
